\chapter{Aarsnes-Shor Model}
\label{ch:aarnessshormodel}

\section{Model Description}
The model simulates torsional vibration of the drill string induced by Coulomb friction and viscous damping which are modeled as distributed source term. The effect of this Coulomb friction becomes prominent as the well inclination increases, therefore this model can be effective in predicting the drill string dysfunctions in high inclined wells. Currently, the model is only applicable for torsional mode simulation but the axial mode will be added soon. The governing equations of torsional motion are solved by finite difference method (FDM) by discretizing the drill string. Assumptions of the model are: 1) no bit-rock interaction, 2) no lateral and axial motion, 3) the effects of cuttings distribution on the friction is homogeneous and 4) the transition from static to dynamic coulomb friction is modeled as a jump. 

Two different versions of the codes are available which are written in MATLAB and PYTHON. The MATLAB ver. is more matured and the validation with field data was also conducted \cite{ref:aarsnes2017a}. One the other hand, PYTHON ver. is relatively recent version and the axial mode will be added on this version. Both codes are based on the same mathematic background and applies finite difference method to solve the torsional vibration of the drill string. However, while PYTHON ver. directly solves the governing equation for angular velocity and torque seperately, MATLAB ver. introduces Riemann invariants and combines the torque and angular velocity in the governing equation and solves at once. The comparison between two models are explained in more detail in next section. 

\section{Top Drive Model}
The model contains PI-controller on the top drive. Therefore, boundary condition at the top is given by top drive torque and velocity calculated from top drive set point velocity. Torque on top drive are derived as:

\begin{equation}\label{AS_err}
  e = w_{sp} - w_{TD}
\end{equation}

\begin{equation}\label{AS_Ie}
  I_e = \int_{0}^{t}e(\xi)d\xi
\end{equation}

\begin{equation}\label{AS_tau_m}
  tau_{td} = K_pe + k_iI_e
\end{equation}

where $w_{sp}$ is set point velocity, $w_{td}$ is top drive velocity, $\tau_{td}$ is top drive torque, $K_p$ and $K_i$ are proportional and integral gain, respectively. $K_p$ and $K_i$ are normally given value from the field. The top drive velocity, $W_{td}$ is then obtained by dynamics:

\begin{equation}\label{AS_w_td}
  \frac{\partial w_{td}}{\partial t} = \frac{1}{J_{td}}(\tau_{td} - \tau_0)
\end{equation}

where $J_{td}$ is top drive inertia, $\tau_{0}$ is the torque on top of the drill string. The angular velocity at the top of the drill string is assume to be same as top drive velocity $w_0 = w_{td}$.

\section{Bit Model}
The model assumes the toque on bit to be constant. The test cases for this projects are off-bottom scenario with not bit-rock contact, therefore, the torque on bit is fixed to zero. In addition, model does not consider weight on bit since current model is only for torsional mode. 

\section{Friction Model}
The Coulomb friction is modeled as a jump. In other words, the friction is constant with transition between static and dynamic friction. The static friction is applied when the angular velocity of the drill string is below the given threshold, while the friction transit to dynamic friction when the angular velocity is above the threshold. The static friction is obtained from normal force along the drill string and static friction factor. On the other hand, the dynamic friction is simply obtained as a certain ratio of the static friction. More details can be seen from equations below:

The Coulomb friction $\mathcal{F}(w,x)$ is modeled as an inclusion which is shown in \equationname~\ref{equation_A-S_columnbfriciton}. The parameters for the equations can be seen from \figurename~\ref{figure_AS_equation_schematic}.
\begin{equation}\label{equation_A-S_columnbfriciton}
  \begin{cases}
     \mathcal{F}(w,x) = F_d(x), & \mbox{if } w>w_c \\
     \mathcal{F}(w,x) \in [-F_c(x), F_c(x)], & \mbox{if } |w|<w_c \ \\
     \mathcal{F}(w,x) = -F_d(x), & \mbox{if } w < -w_c.
  \end{cases}
\end{equation}
where $w_c$ is the angular velocity threshold for Coulomb friction transition from static to dynamic. x is the location of the drill string, w is the angular velocity at x, $F_d$ and $F_c$ are dynamic and static Coulomb torque, respectively. For condition $|w|<w_c$, $\mathcal{F}(w,x)$ takes the boundary values $\pm F_C(x)$.

\begin{figure}[!hpt]
  \centering
  \includegraphics[width=2.5in]{AS_parameters}
  \caption[Schematic of distributed drill string in deviated well]{Schematic of distributed drill string in deviated well and indication of parameters used in the equations \cite{ref:aarsnes2017a}.}\label{figure_AS_equation_schematic}
\end{figure}

\section{Mathematical Background}\label{SubSec_AS_mathematicalbackground}
The model is based on the equations of angular motion, here named wave equation, which are:
\begin{equation}\label{AS-motion}
  J\rho\frac{\partial w(t,x)}{\partial t} + \frac{\partial \tau (t,x)}{\partial x} = S(w,x) 
\end{equation}
\begin{equation}
 \frac{\partial\tau(t,x)}{\partial t} + JG\frac{\partial w(t,x)}{\partial x} = 0 
\end{equation}
where J is polar moment of inertia and $\rho$ is material density, $w(t,x)$ is angular velocity, $\tau(t,x)$ is torque, and S is the source term which can be represented as:
\begin{equation}\label{AS-sourceterm}
  S(w,x) = -k_t \rho J w(t,x) - \mathcal{F}(w,x)
\end{equation}
where $k_t$ is damping constant which is viscous shear stresses from drilling mud and cuttings bed, and $\mathcal{F}(w,x)$ is Coulomb friction between the drill string and the borehole that is derived from \equationname~\ref{equation_A-S_columnbfriciton}-\ref{equation_A-S_static_fric}. 

\subsection{Numerical Implementation of MATALB ver.}
The partial governing equations \equationname~\ref{AS-motion}, and \ref{AS-sourceterm} are transformed into their Riemann invariants solved by first order upwind scheme. The Riemann invariants are defined as:
\begin{equation}\label{AS-Riemann}
  \alpha = w + \frac{c_t}{JG}\tau, \quad \beta=w-\frac{c_t}{JG}\tau
\end{equation}
where $c_t = \sqrt{\frac{\rho}{J}}$ is the velocity of the torsional wave. It can be noticed that angular velocity and torque can be obtained from the relationship below: 
\begin{equation}\label{equation_Riemann_relation1}
  \frac{\alpha + \beta}{2} = w
\end{equation}
\begin{equation}\label{equation_Riemann_relation2}
  J \rho \frac{\alpha + \beta}{2c_t} = \tau
\end{equation}
The variable $\alpha$, $\beta$ satisfies the PDE system below: 
\begin{equation}\label{AS-Riemann_alpha}
  \frac{\partial \alpha}{\partial t} + c_t\frac{\partial \alpha}{\partial x} = -\mathcal{S}
\end{equation}
\begin{equation}\label{AS-Riemann_beta}
  \frac{\partial \beta}{\partial t} - c_t\frac{\partial \beta}{\partial x} = -\mathcal{S}
\end{equation}
Therefore, angular velocity w, and torque $\tau$ can be obtained by solving $\alpha$ and $\beta$.
The source term $\mathcal{S}$ is:
\begin{equation}\label{AS-source}
  \mathcal{S} = \frac{S}{J \rho} j= k_t(\alpha + \beta) + \frac{1}{J \rho} \mathcal{F}
\end{equation}
where $k_t$ is damping coefficient and $\mathcal{F}$ is Coulomb friction defined in \equationname~\ref{equation_A-S_columnbfriciton}. The boundary conditions are given as:
\begin{equation}\label{AS-BC}
  w_{p,top} = w_{TD} \quad \tau_{c,bottom} = \tau_{bit}
\end{equation}
where subscript p, c represents drill pipe and drill collar. In this project, $\tau_{bit}$ is assumed to be 0 with the off-bottom scenario. 
Additionally, the conditions at the drill pipe - drill collar interface are imposed:
\begin{equation}\label{AS-interface}
  w_{p,interface} = w_{c,interface}, \quad \tau_{p,interface} = \tau_{c,interface}
\end{equation}
\equationname~\ref{AS-BC} can be re-written from the relationship from \equationname~\ref{equation_Riemann_relation1}, and \ref{equation_Riemann_relation2} as:
\begin{equation}\label{AS-riemannBC}
  \alpha_{p,top} = -\beta_{p,top} + 2*w_{TD}, \quad \beta_{c,bottom} = \alpha_{c,bottom} - 2\tau_{bit} \frac{c_t}{J_c G_c}
\end{equation}
Also, \equationname~\ref{AS-interface} can be re-written as:
\begin{equation}\label{AS-riemanninterface}
\begin{split}
    & \beta_{p,bottom} = \frac{1}{1+\overline{Z}}\left(\alpha_{p,bottom}(1-\overline{Z}) + 2\overline{Z}\beta_{c,top} \right) \\
    & \alpha_{c,top} = \frac{1}{1+\overline{Z}}\left(2*\alpha_{p,bottom} - \beta_{c,top}(1-\overline{Z})\right)
\end{split}
\end{equation}
where $\overline{Z}$ is the relative magnitude of the impedance:
\begin{equation}\label{AS_Zbar}
  \overline{Z} = \left[\frac{c_t}{JG}\right]_{p,bottom} / \left[\frac{c_t}{JG}\right]_{c,top}
\end{equation}

\figurename~\ref{AS_discretizeDS} illustrates the schematic view of the discretized drillstring with boundary conditions, and interface conditions in terms of Riemann invariants. 

\begin{figure}[!hbt]
  \centering
  \includegraphics[width=6in]{AS_discretizedDS}
  \caption[Schematic of discretized drillstring and boundary conditions]{Schematic of discretized drillstring, boundary conditions, and interface conditions based on Riemann invariants $\alpha$, and $\beta$.}\label{AS_discretizeDS}
\end{figure}

The PDE is solved from upwind scheme according to (for sell size $\Delta x$ and time step $\Delta t$, at cell j and time step k):
\begin{equation}\label{AS-upwind}
  \mathcal{F}_{j}^k = \frac{1}{2 \Delta t}\left(a_j^k - c_t \frac{\Delta t}{\Delta x}(a_j^k - a_{j-1}^k) + \beta_j^k + c_t \frac{\Delta t}{\Delta x}(\beta_{j+t}^k-\beta_j^k) + \Delta t k_t (\alpha_j^k + \beta_j^k)\right)
\end{equation}

\subsection{Results}
This section briefly summarizes the code flow (PYTHON version), since it is slightly different in the way they calculated compared to the MATLAB version. The input for torsional modeling is summarized in \tablename~\ref{AS_inptut_params}.

\begin{table}[!hbt]
\centering
\begin{tabularx}{\linewidth-0.75in}{|c|c|L|}
\hline
\tablecolumnheadervlinesone{Parameter} & \tablecolumnheadervlinestwo{Units} & \tablecolumnheadervlinestwo{Notes} \\                                                              
\hline
Simulation length & s & Total simulation time \\                                                  
\hline
Bit depth & ft & MD of the bit \\                                                   
\hline
$w_c$ & rad/s & Cut-off angular velocity (static, dynamic transition)\\                                                              
\hline
$\mu_s$ & -& Static friction factor\\
\hline
$\mu_k$ & - & Kinetic friction factor \\ 
\hline
$K_t$ &- & Inertial torsional damping \\                                                  
\hline
$K_s$ &- & Viscous damping coefficient \\                                                   
\hline
$\rho$ & $lbf/ft_3$ & Drill string density \\                                                       
\hline
G & $lbf/ft^2$ & Shear modulus   \\                                                         
\hline
E & $lbf/ft^2$ & Young's modulus \\                                                              
\hline
$K_p$ & $lb$-$ft$ & P-gain of top drive (PI controller) \\
\hline
$K_i$ & $lb$-$ft/s$ &I-gain of top drive (PI controller)\\ 
\hline
$J_{TD}$ & $lb$-$ft^2$ & Top drive inertia \\
\hline
ramp speed & RPM/s & ramp speed of top drive\\
\hline
\end{tabularx}
\caption[Input parameters of Aarsnes-Shor model]{Input parameters of Aarsnes-shor model. well trajectory, top drive set velocity, and bit constant are the additional parameters which are not included in this table.}\label{AS_inptut_params}
\end{table}

First, the static behavior is calculated after descritizing the drillstring. Since the model assumes the off-bottom scenario, WOB and TOB is zero. The normal force, tension, and momentum throughout the drillstring is calculated (Johancsik et al., 1984). Then, the angular velocity, torque is calculated by iterating untill the desired simulation length reaches. The calculation procedure is shown below: 

%\begin{algorithm}
%\caption{Aarsnes-Shor model pseudocode algorithm}\label{AS-pseudocode}
%\begin{algorithmic}
%\For{\texttt{i = 1: simulation length/dt}}
%\State nstep = freq/dt
%\For{\texttt{j=1:nstep}}
%    \State 1. Set the topdrive setpoint torque and angular velocity
%    \State $w_{SP}(t+1)=w_{SP}(t)\pm ramp*dt$
%    \State $e=w_{SP}(t+1)-w_{TD}(t), \quad I=e*dt$
%    \State $\tau_{TD}(t+1) \gets \tau_{TD}(t) + (k_e e + k_i I)*dt$
%    \State $w_{TD}(t+1) \gets w_{TD}(t) + (\tau_{TD}(t+1)-\tau_{top}(t))/J_{TD}*dt$
%    \State 2. Bit rotation
%    \State $\tau_{bit}(t+1) \gets bitconstant * w_{bottom}(t)$
%    \State $w_{bit}(t+1) \gets w_{bottom}(t)$
%    \State 3. Update topdrive torque (?)
%    \State $\tau_{TD}(t+1) \gets \tau_{TD}(t+1)-J_{TD}(w_{TD}(t+1)-w_{TD}(t))/dt$
%    \State 3. Calculate source term
%    \State $fric \gets \mu_k*f_n*r (friction)$
%    \State $Iner \gets k_t*\rho*J*(w(t)-w(t-1)) (intertia\:damping)$
%    \State $vis \gets k_s*w(t) (viscous\:damping)$
%    \State $S \gets (fric+iner+vis)/dx$
%    \State 4. Update the torque and angular velocity \Comment{eqn.\ref{AS-motion}}
%    \State $\tau(t+1) \gets \tau(t) - JG*dl/dt (w_n(t)-w_(n-1)(t))$ \Comment{n is discretized number}
%    \State $w(t+1) \gets w(t) 2*dt/(J*\rho)\left[(\tau_n(t)-\tau_{n-2}(t))/(2*dx)+S\right]$
%    \EndFor
%\State $\overline{w} \gets \overline{w} \cdot Kernel$ \Comment{remove high frequency noise}
%\State $\overline{\tau} \gets \overline{\tau} \cdot Kernel$
%\EndFor
%
%\end{algorithmic}
%\end{algorithm}

%\newcommand{\codecomment}[1]{\hfill #1}
%\pushinitialcodeindent{0in}
%
%\begin{code}[\codenumbering]{}
%\codeitemnonumber \pseudocodefor{} i = 1 simulation length/dt
%	\stepcodelevel{}
%	\codeitemnonumber nstep = freq/dt
%	\codeitemnonumber \pseudocodefor{} {j=1:nstep}
%		\stepcodelevel{}
%	    \codeitemnonumber 1. Set the topdrive setpoint torque and angular velocity
%	    \codeitemnonumber $w_{SP}(t+1)=w_{SP}(t)\pm ramp*dt$
%	    \codeitemnonumber $e=w_{SP}(t+1)-w_{TD}(t), \quad I=e*dt$
%	    \codeitemnonumber $\tau_{TD}(t+1) \gets \tau_{TD}(t) + (k_e e + k_i I)*dt$
%	    \codeitemnonumber $w_{TD}(t+1) \gets w_{TD}(t) + (\tau_{TD}(t+1)-\tau_{top}(t))/J_{TD}*dt$
%	    \codeitemnonumber 2. Bit rotation
%	    \codeitemnonumber $\tau_{bit}(t+1) \gets bitconstant * w_{bottom}(t)$
%	    \codeitemnonumber $w_{bit}(t+1) \gets w_{bottom}(t)$
%	    \codeitemnonumber 3. Update topdrive torque (?)
%	    \codeitemnonumber $\tau_{TD}(t+1) \gets \tau_{TD}(t+1)-J_{TD}(w_{TD}(t+1)-w_{TD}(t))/dt$
%	    \codeitemnonumber 4. Calculate source term
%	    \codeitemnonumber $fric \gets \mu_k*f_n*r (friction)$
%	    \codeitemnonumber $Iner \gets k_t*\rho*J*(w(t)-w(t-1)) (intertia\:damping)$
%	    \codeitemnonumber $vis \gets k_s*w(t) (viscous\:damping)$
%	    \codeitemnonumber $S \gets (fric+iner+vis)/dx$
%	    \codeitemnonumber 5. Update the torque and angular velocity \codecomment{eqn.\ref{AS-motion}}
%	    \codeitemnonumber $\tau(t+1) \gets \tau(t) - JG*dl/dt (w_n(t)-w_(n-1)(t))$ \codecomment{n is discretized number}
%	    \codeitemnonumber $w(t+1) \gets w(t) 2*dt/(J*\rho)\left[(\tau_n(t)-\tau_{n-2}(t))/(2*dx)+S\right]$
%	    \prevcodelevel{}
%	\codeitemnonumber \pseudocodedonefor{}
%	\codeitemnonumber $\overline{w} \gets \overline{w} \cdot Kernel$ \codecomment{remove high frequency noise}
%	\codeitemnonumber $\overline{\tau} \gets \overline{\tau} \cdot Kernel$
%	\prevcodelevel{}
%\codeitemnonumber \pseudocodedonefor{}
%\end{code}
%\popinitialcodeindent{}
%\begin{figure}[!hbt]
%  \centering
%  \includegraphics[width=6in]{algorithm_ASmodel}
%\end{figure}
%

%\end{figure}
%\begin{algorithm}
%\caption{Aarsnes-Shor model pseudocode algorithm}\label{AS-pseudocode}
%\begin{algorithmic}
%\For{\texttt{i = 1: simulation length/dt}}
%\State nstep = freq/dt
%\For{\texttt{j=1:nstep}}
%    \State 1. Set the topdrive setpoint torque and angular velocity
%    \State $w_{SP}(t+1)=w_{SP}(t)\pm ramp*dt$
%    \State $e=w_{SP}(t+1)-w_{TD}(t), \quad I=e*dt$
%    \State $\tau_{TD}(t+1) \gets \tau_{TD}(t) + (k_e e + k_i I)*dt$
%    \State $w_{TD}(t+1) \gets w_{TD}(t) + (\tau_{TD}(t+1)-\tau_{top}(t))/J_{TD}*dt$
%    \State 2. Bit rotation
%    \State $\tau_{bit}(t+1) \gets bitconstant * w_{bottom}(t)$
%    \State $w_{bit}(t+1) \gets w_{bottom}(t)$
%    \State 3. Update topdrive torque (?)
%    \State $\tau_{TD}(t+1) \gets \tau_{TD}(t+1)-J_{TD}(w_{TD}(t+1)-w_{TD}(t))/dt$
%    \State 3. Calculate source term
%    \State $fric \gets \mu_k*f_n*r (friction)$
%    \State $Iner \gets k_t*\rho*J*(w(t)-w(t-1)) (intertia\:damping)$
%    \State $vis \gets k_s*w(t) (viscous\:damping)$
%    \State $S \gets (fric+iner+vis)/dx$
%    \State 4. Update the torque and angular velocity \Comment{eqn.\ref{AS-motion}}
%    \State $\tau(t+1) \gets \tau(t) - JG*dl/dt (w_n(t)-w_(n-1)(t))$ \Comment{n is discretized number}
%    \State $w(t+1) \gets w(t) 2*dt/(J*\rho)\left[(\tau_n(t)-\tau_{n-2}(t))/(2*dx)+S\right]$
%    \If{$\tau(t+1)<fric$ or $w(t+1)<w_c$}
%    \State $w(t+1) = 0$
%    \EndIf
%    \EndFor
%\State $\overline{w} \gets \overline{w} \cdot Kernel$ \Comment{remove high frequency noise}
%\State $\overline{\tau} \gets \overline{\tau} \cdot Kernel$
%\EndFor
%\end{algorithmic}
%\end{algorithm}

%\newcommand{\codecomment}[1]{\hfill #1}
%\pushinitialcodeindent{0in}
%
%\begin{code}[\codenumbering]{}
%\codeitemnonumber \pseudocodefor{} {\texttt{i = 1: simulation length/dt}}
%	\stepcodelevel{}
%	\codeitemnonumber nstep = freq/dt
%	\pseudocodefor{} {\texttt{j=1:nstep}}
%		\stepcodelevel{}
%	    \codeitemnonumber 1. Set the topdrive setpoint torque and angular velocity
%	    \codeitemnonumber $w_{SP}(t+1)=w_{SP}(t)\pm ramp*dt$
%	    \codeitemnonumber $e=w_{SP}(t+1)-w_{TD}(t), \quad I=e*dt$
%	    \codeitemnonumber $\tau_{TD}(t+1) \gets \tau_{TD}(t) + (k_e e + k_i I)*dt$
%	    \codeitemnonumber $w_{TD}(t+1) \gets w_{TD}(t) + (\tau_{TD}(t+1)-\tau_{top}(t))/J_{TD}*dt$
%	    \codeitemnonumber 2. Bit rotation
%	    \codeitemnonumber $\tau_{bit}(t+1) \gets bitconstant * w_{bottom}(t)$
%	    \codeitemnonumber $w_{bit}(t+1) \gets w_{bottom}(t)$
%	    \codeitemnonumber 3. Update topdrive torque (?)
%	    \codeitemnonumber $\tau_{TD}(t+1) \gets \tau_{TD}(t+1)-J_{TD}(w_{TD}(t+1)-w_{TD}(t))/dt$
%	    \codeitemnonumber 4. Calculate source term
%	    \codeitemnonumber $fric \gets \mu_k*f_n*r (friction)$
%	    \codeitemnonumber $Iner \gets k_t*\rho*J*(w(t)-w(t-1)) (intertia\:damping)$
%	    \codeitemnonumber $vis \gets k_s*w(t) (viscous\:damping)$
%	    \codeitemnonumber $S \gets (fric+iner+vis)/dx$
%	    \codeitemnonumber 5. Update the torque and angular velocity \codecomment{eqn.\ref{AS-motion}}
%	    \codeitemnonumber $\tau(t+1) \gets \tau(t) - JG*dl/dt (w_n(t)-w_(n-1)(t))$ \codecomment{n is discretized number}
%	    \codeitemnonumber $w(t+1) \gets w(t) 2*dt/(J*\rho)\left[(\tau_n(t)-\tau_{n-2}(t))/(2*dx)+S\right]$
%	    \prevcodelevel{}
%	\codeitemnonumber \pseudocodedonefor{}
%	\codeitemnonumber $\overline{w} \gets \overline{w} \cdot Kernel$ \codecomment{remove high frequency noise}
%	\codeitemnonumber $\overline{\tau} \gets \overline{\tau} \cdot Kernel$
%	\prevcodelevel{}
%\codeitemnonumber \pseudocodedonefor{}
%\end{code}
%\popinitialcodeindent{}

\section{Comparison between MATLAB ver. and PYTHON ver.}

\subsection{Effect of PI-controller}

Before conducting the tests, MATLAB ver. and PYTHON ver. were compared. The comparison was conducted with off-bottom scenario in vertical well. The detailed description of the test scenario can be seen in \figurename~\ref{figure_verticalwell}, and \ref{figure_topdrive_VSP}. and \tablename~\ref{table_verticalwell_input}.
 
The A-S model contains PI-controller on top drive for more realistic simulation, however, the results were sensitive to input parameters which are $k_p, k_i, J_{TD}$, and ramp speed (\tablename~\ref{AS_inptut_params}), especially when the exact value is not provided. \figurename~\ref{figure_topdrive_sensitivity} illustrates the comparison between MATLAB ver. and PYTHON ver. when same top drive related parameters used 
(\tablename~\ref{table_topdrivesensitivity_input}). Please note that the model was run with same input parameters with different units (MATLAB ver: Metric unit, PYTHON ver: Imperial unit). 

\begin{testcasetable}
$k_p$ & $38e^3 \; Nm/s $ & $28e3\; lbfft/s$ & p-gain \\                                                  
\hline
$k_i$ & $100e^3 \; Nm$ & $74e^3\; lbfft$  & i-gain \\                                                  
\hline
$J_{TD}$ & $2900 \; kgm^2 $ & $ 68818 \; lbft^2$ & top drive inertia\\                                                       
\hline
\end{tabularx}
\caption[Top drive related parameters for comparison.]{Top drive related parameters for comparison.}\label{table_topdrivesensitivity_input}
\end{testcasetable}

\begin{figure}[!hbt]
  \centering
  \includegraphics[width=6in]{verticalwell_topdrive_sensitivity}
  \caption[Comparison of drillstring response to same top drive parameters]{Comparison of top drive and bit responses with same top drive parameters between MATLAB ver. and PYTHON ver. a): Results from MATLAB ver., and b) : results from PYTHON ver.}\label{figure_topdrive_sensitivity}
\end{figure}

The results implies that, for the further study, we need an exact input parameters or remove the PI-controller from the top drive. Therefore, the codes were modified and top drive was removed from the system assuming the fixed velocity at the top of the drill string. The modified code enables reducing the parameters of the model for more simple comparison between different models for the future work. The flowchart of PI-controller removal is shown in \figurename~\ref{figure_Topdriveremove_math}.
\begin{figure}[!hbt]
  \centering
  \includegraphics[width=5in]{Topdriveremove_math}
  \caption[flow chart of top drive elimination]{Flow chart of top drive elimination. The modification of the model assumes only drill string in the model and it rotates with given (fixed) velocity at the top of the drill string.}\label{figure_Topdriveremove_math}
\end{figure}

The comparison of bit and top drive angular velocity and torque between when the top drive is existed and removed are depicted in \figurename~\ref{figure_topdriveremove_MATLAB} and \ref{figure_topdriveremove} for MATLAB and PYTHON ver, respectively. In the modified code, top drive velocity and torque will refer that of top of the drill string. The original and modified code showed almost the same behavior except during the very first stage when the top drive velocity increased from 0 to 40 RPM. The spikes can be seen when the top drive with PI-controller exits. Additionally, the decaying of the vibration amplitude was  observed in the original code which can be clearly seen in the MATLAB ver. This is due to the damping effect from the PI controller acts while controlling the top drive velocity and it eventually converges the vibration. In summary, There are mainly two advantages of removing the PI controller in this project and we can achieve 1): insensitive model to top drive input parameters, 2) removing damping effect from the PI-controller.
